# Domain Driven Design

## Backend

Standard Typescript files to start a project using DDD. Inspired by the principles of [Domain Driven Design](https://khalilstemmler.com/articles/categories/domain-driven-design/).

### Building block components used in each subdomain

#### Entity

- Has an id (preferably a GUID instead of an int generated by the database, because business transactions do not depend on persistence, they can be persisted after other operations performed on the model behavior)
- The entity class should not have public property setters, setting a property should be a behavior method of the class. - Entity relations should not contain a reference to another entity class, they can only hold the id of another entity
- If a business transaction needs a reference to other entities in the relation, aggregates should be used instead (aggregates can contain a reference to other aggregate roots, which are entity classes by definition)
- Must validate their state and prevent any invalid state.

#### Value Object

- They are identified only by their values, not by their ids (e.g. money is a value object as long as we are not tracking individual bills, if we need to track individual bills then it should be a bills entity)
- Can be used to measure or describe things (name, description, amount, height, date, time, range, address, etc.)
- You can combine other value types that usually go together into a new value object type, like address (city, street, country, zip code) or ... range or ... type
- Prefer to put behavior in value objects instead of entities because value objects are immutable and have no side effects (like changing their state or changing the state of any entity)
- Can be part of an entity
- They should be immutable, behaviors should not change the state of a value object, but can instead create a new value object
- Can be persisted, but only as part of an entity, not individually

#### Aggregate

- Encapsulate and are composed of entity classes and value objects that change together in a business transaction
- The Root Aggregate must be an entity, an aggregate can even be a single entity
- The aggregate can keep a reference to other root aggregates, but not to other entity classes that are not the aggregate roots themselves
- The aggregate should not keep a reference to other aggregate root entity classes if those other entities do not change along with this aggregate root entity
- The aggregate can also keep the id of another entity, but keeping too many foreign key ids is a domain modeling error smell.
- If deleting an entity has a cascading effect on the other entities referenced by the class, those entities are part of the same aggregate, otherwise they should not be inside this aggregate.

#### Domain Event

- Can be generated when a state change occurs in an entity.
- Decouples models from each other
- Used only when an event needs to be handled within a different model than the one that generated this event, or handled within a domain service or even an application service.
- These are immutable classes, which represent the past, named in the past tense and cannot change (... Changed, ... Happened, etc.)
- Must include the time when this event was generated, as well as any other useful information to handle the event, as well as the id of the entity that generated the event.
- Must not have behavior.
- Domain events are generated synchronously, if an asynchronous task needs to be performed, this can be done within the event handler (async-await pattern).
- External applications can also be triggered using a message queue or a service bus.

#### Domain Service

- Domain services should not maintain state (application services are not domain services, they are in the outer layer near the UI layer and can maintain the state of the application/task).
- Domain services have very little behavior and only what does not fit cohesively into any domain model.
- Domain services sit in the core domain layer along with entities, value objects, aggregates and domain events and expose domain models in their interfaces.

#### Repository

- Persist and read aggregates to/from database or file system.
- Should have an interface close to a collection, but should only allow operations needed for this aggregate (e.g. an aggregate may not need to be updated or deleted).
- Should not be generic (should bespecific to the aggregate type).
- Can have specific query methods if needed (like FindByName() etc.).
- Do not use lazy loading, instead use eager loading (use Include(...) in Infra Model), otherwise you may face "N+1 problem" and excessive number of queries sent to the database
- Can have specific methods that load only some of the columns of a table
- For add/update/remove operation, the repository must commit to the database by itself (call ...Context.Save() at the end), because aggregate operations must be ACID transactions
- The repository interface is inside the domain layer, but the implementations are inside the infrastructure layer.
- Repositories are not used inside the domain models (entities, value objects, aggregates).

#### Use Cases (Application Service)

- Use Cases or Application Service are classes that execute command to perform an operation in the application layer. - They do not contain domain-specific business logic.
- They are used to retrieve domain entities (and anything else) from persistence and the external world.
- They pass control to an aggregate to execute domain logic using an aggregate method.
- They pass multiple entities to a domain service to facilitate their interaction.
- They have low levels of Cyclomatic Complexity.

#### Mapper

- Responsible for translating the structure of a domain model to an infrastructure and persistence structure and vice versa.
- They do not contain business logic.
- They do not perform state validations.

### The Layers

DDD is not an architecture. DDD (Domain Driven Design) is a software modeling whose objective is to facilitate the implementation of complex rules and processes, where it aims to divide responsibilities by layers and is independent of the technology used. In other words, DDD is a philosophy focused on the business domain.

### For architecture

I suggest the hexagonal architecture

[Learn more](https://br.sensedia.com/post/use-of-the-hexagonal-architecture-pattern)



### Folder Pattern

Based on the hexagonal architecture, suggestion for organizing folders

